<?php
// $Id$

/**
 * @file
 * Implements the shopping cart system and add to cart features.
 *
 * In Drupal Commerce, the shopping cart is really just an order that makes
 * special considerations to associate it with a user and
 */


/**
 * Implements hook_menu().
 */
function commerce_cart_menu() {
  $items = array();

  $items['cart'] = array(
    'title' => t('Shopping cart'),
    'page callback' => array('commerce_cart_view'),
    'access arguments' => array('access content'),
    'file' => 'includes/commerce_cart.pages.inc',
  );

  $items['checkout'] = array(
    'title' => 'Checkout',
    'page callback' => 'commerce_cart_checkout_router',
    'access arguments' => array('access checkout'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_cart.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_commerce_order_state_info().
 */
function commerce_cart_commerce_order_state_info() {
  $order_states = array();

  $order_states['cart'] = (object) array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'description' => t('Orders in this state have not been completed by the customer yet.'),
    'weight' => -5,
    'default_status' => 'cart',
  );

  return $order_states;
}

/**
 * Implements hook_commerce_order_status_info().
 */
function commerce_cart_commerce_order_status_info() {
  $order_statuses = array();

  $order_statuses['cart'] = (object) array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'state' => 'cart',
    'cart' => TRUE,
  );

  return $order_statuses;
}

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_cart_commerce_checkout_pane_info() {
  $checkout_panes = array();

  $checkout_panes['cart_contents'] = (object) array(
    'title' => t('Shopping cart contents'),
    'base' => 'commerce_cart_contents_pane',
    'file' => 'includes/commerce_cart.checkout_pane.inc',
    'page' => 'checkout',
  );

  return $checkout_panes;
}

/**
 * Implements hook_commerce_checkout_complete().
 */
function commerce_cart_commerce_checkout_complete($form, &$form_state, $order) {
  // Move the cart order ID to a completed order ID.
  if (!empty($_SESSION['commerce_cart_order_id'])) {
    $_SESSION['commerce_cart_completed_orders'][] = $_SESSION['commerce_cart_order_id'];
    unset($_SESSION['commerce_cart_order_id']);
  }
}

/**
 * Implements hook_commerce_line_item_summary_link_info().
 */
function commerce_cart_commerce_line_item_summary_link_info() {
  return array(
    'view_cart' => array(
      'title' => t('View cart'),
      'href' => 'cart',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 0,
    ),
    'checkout' => array(
      'title' => t('Checkout'),
      'href' => 'checkout',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 5,
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function commerce_cart_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'commerce_cart') . '/includes/views',
  );
}

/**
 * Implements hook_theme().
 */
function commerce_cart_theme() {
  return array(
    'commerce_cart_empty_block' => array(
      'variables' => array(),
    ),
    'commerce_cart_empty_page' => array(
      'variables' => array(),
    ),
    'commerce_cart_block' => array(
      'variables' => array('order' => NULL, 'contents_view' => NULL),
      'path' => drupal_get_path('module', 'commerce_cart') . '/theme',
      'template' => 'commerce-cart-block',
    ),
    'commerce_cart_form_product_table' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_user_login().
 */
function commerce_cart_user_login(&$edit, $account) {
  // Merge any items in the anonymous cart with the authenticated user's cart.

  // Get the anonymous cart if it exists.
  if ($anonymous_order = commerce_cart_order_load()) {
    // If the anonymous user had any items in the cart, add them to the user's
    // authenticated cart.
    if (count($anonymous_order->line_items[LANGUAGE_NONE]) > 0) {
      // Add each of the anonymous cart items to the authenticated user's cart.
      $line_item_ids = array();

      foreach ($anonymous_order->line_items[LANGUAGE_NONE] as $line_item_reference) {
        $line_item_ids[] = $line_item_reference['line_item_id'];
      }

      foreach (commerce_line_item_load_multiple($line_item_ids) as $line_item) {
        commerce_cart_product_add($account->uid, $line_item->product[LANGUAGE_NONE][0]['product_id'], $line_item->quantity);
      }

      // Delete the anonymous order from the database and clear the reference.
      commerce_order_delete($anonymous_order->order_id);
      unset($_SESSION['commerce_cart_order_id']);
    }
  }

  // Set the uid for any completed orders if they exist.
  if (!empty($_SESSION['commerce_cart_completed_orders'])) {
    foreach ((array) $_SESSION['commerce_cart_completed_orders'] as $order_id) {
      if ($order = commerce_order_load($order_id)) {
        if ($order->uid == 0) {
          $order->uid = $account->uid;
          commerce_order_save($order);
        }
      }
    }

    unset($_SESSION['commerce_cart_completed_orders']);
  }
}

/**
 * Implements hook_block_info().
 */
function commerce_cart_block_info() {
  $blocks = array();

  // Define the basic shopping cart block and hide it on the checkout pages.
  $blocks['cart'] = array(
    'info' => t('Shopping cart'),
    'cache' => DRUPAL_NO_CACHE,
    'visibility' => 0,
    'pages' => 'checkout*',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function commerce_cart_block_view($delta) {
  global $user;

  // Prepare the display of the default Shopping Cart block.
  if ($delta == 'cart') {
    // First check for items in the shopping cart.
    $order = commerce_cart_order_load($user->uid);

    // If the cart is empty...
    if (!$order || empty($order->line_items)) {
      // Display an appropriate message.
      $content = theme('commerce_cart_empty_block');
    }
    else {
      // Build the variables array to send to the cart block template.
      $variables = array(
        'order' => $order,
        'contents_view' => commerce_embed_view('commerce_cart_block', 'defaults', array($order->order_id)),
      );

      $content = theme('commerce_cart_block', $variables);
    }

    return array('subject' => t('Shopping cart'), 'content' => $content);
  }
}

/**
 * Themes an empty shopping cart block's contents.
 */
function theme_commerce_cart_empty_block() {
  return '<div class="cart-empty-block">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Themes an empty shopping cart page.
 */
function theme_commerce_cart_empty_page() {
  return '<div class="cart-empty-page">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Loads the shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the customer whose cart to load. If left 0, attempts to load
 *     an anonymous order from the session.
 *
 * @return
 *   The fully loaded shopping cart order or FALSE if non-existent.
 */
function commerce_cart_order_load($uid = 0) {
  // Loaded orders will be cached keyed by $uid.
  $cart_orders = &drupal_static(__FUNCTION__);

  // First return the cached order if it has been loaded already.
  if (!isset($cart_orders[$uid])) {
    $order_id = FALSE;

    // If a customer uid was specified...
    if ($uid) {
      // Create an array of valid shopping cart order statuses.
      $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

      // Look for the user's most recent shopping cart order, although they
      // should never really have more than one.
      $order_id = db_query('SELECT order_id FROM {commerce_order} WHERE uid = :uid AND status IN (:status_ids) ORDER BY order_id DESC', array(':uid' => $uid, ':status_ids' => $status_ids))->fetchField();
    }
    else {
      // Otherwise look for a shopping cart order ID in the session.
      if (!empty($_SESSION['commerce_cart_order_id'])) {
        $order_id = $_SESSION['commerce_cart_order_id'];
      }
    }

    // If a valid order ID was found, load the order now.
    if ($order_id) {
      $cart_orders[$uid] = commerce_order_load($order_id);
    }
    else {
      $cart_orders[$uid] = FALSE;
    }
  }

  return $cart_orders[$uid];
}

/**
 * Resets the cached array of shopping cart orders.
 */
function commerce_cart_orders_reset() {
  $cart_orders = &drupal_static('commerce_cart_order_load');
  $cart_orders = NULL;
}

/**
 * Creates a new shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the user for whom to create the order. If left 0, the order will
 *     be created for the current user and associated with his or her session.
 *
 * @return
 *   The newly created shopping cart order object.
 */
function commerce_cart_order_new($uid = 0) {
  // Create the new order with the customer's uid and the cart order status.
  $order = commerce_order_new($uid, 'cart');
  $order->log = t('Created as a shopping cart order.');

  // Save it so it gets an order ID and return the full object.
  $order = commerce_order_save($order);

  // Reset the cart cache
  commerce_cart_orders_reset();

  // If the user is not logged in, ensure the order ID is stored in the session.
  if (!$uid && empty($_SESSION['commerce_cart_order_id'])) {
    $_SESSION['commerce_cart_order_id'] = $order->order_id;
  }

  return $order;
}

/**
 * Adds the specified product to a customer's shopping cart.
 *
 * @param $uid
 *   The uid of the user whose cart you are adding the product to.
 * @param $product_id
 *   The ID of the product to add to the cart.
 * @param $quantity
 *   The quantity of this product to add to the cart.
 *
 * @return
 *   The entire shopping cart order object or FALSE on failure.
 */
function commerce_cart_product_add($uid, $product_id, $quantity) {
  // Load and validate the specified product ID.
  $product = commerce_product_load($product_id);

  // Fail if the product does not exist or is disabled.
  if (empty($product) || !$product->status) {
    return FALSE;
  }

  // First attempt to load the customer's shopping cart order.
  $order = commerce_cart_order_load($uid);

  // If no order existed, create one now.
  if (empty($order)) {
    $order = commerce_cart_order_new($uid);
  }

  // Determine if the product already exists on the order and increment its
  // quantity instead of adding a new line if it does.
  $line_item_match = NULL;

  // If the order has line items on it...
  if (!empty($order->line_items)) {
    $line_item_ids = array();

    // Build an array of the line item IDs.
    foreach ($order->line_items[LANGUAGE_NONE] as $line_item_reference) {
      $line_item_ids[] = $line_item_reference['line_item_id'];
    }

    // Loop through the line items looking for products.
    foreach (commerce_line_item_load_multiple($line_item_ids) as $line_item) {
      // If this line item matches the product being added...
      if (empty($line_item_match) &&
          $line_item->type == 'product' &&
          $line_item->product[LANGUAGE_NONE][0]['product_id'] == $product_id) {
        // Exit this loop with the $line_item intact so it gets updated.
        $line_item_match = clone($line_item);
      }
    }
  }

  // If no matching line item was found...
  if (empty($line_item_match)) {
    // Create the new product line item.
    $line_item = commerce_product_line_item_new($product, $quantity);

    // Add it to the order's line item reference value.
    $order->line_items[LANGUAGE_NONE][] = array(
      'line_item_id' => $line_item->line_item_id,
    );

    // Save the updated order.
    commerce_order_save($order);
  }
  else {
    // Increment the quantity of the line item and save it.
    $line_item_match->quantity += $quantity;

    commerce_line_item_save($line_item_match);
  }

  // Return the order.
  return $order;
}

/**
 * Builds an appropriate cart form ID based on the products on the form.
 *
 * @see commerce_cart_forms().
 */
function commerce_cart_add_to_cart_form_id($product_ids, $qty = 0) {
  return 'commerce_cart_add_to_cart_form_' . implode('_', $product_ids);
}

/**
 * Implements hook_forms().
 *
 * To provide distinct form IDs for add to cart forms, the product IDs
 * referenced by the form are appended to the base ID,
 * commerce_cart_add_to_cart_form. When such a form is built or submitted, this
 * function will return the proper callback function to use for the given form.
 */
function commerce_cart_forms($form_id, $args) {
  $forms = array();

  // Construct a valid cart form ID from the arguments.
  if (strpos($form_id, 'commerce_cart_add_to_cart_form_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'commerce_cart_add_to_cart_form',
    );
  }

  return $forms;
}

/**
 * Builds an Add to Cart form for a set of products.
 *
 * @param $product_ids
 *   An array of product IDs that will be included in the form.
 * @param $show_quantity
 *   Boolean indicating whether or not the quantity field should be shown;
 *     defaults to FALSE resulting in a hidden field.
 * @param $default_quantity
 *   The value to place in the quantity field, defaults to 1.
 *
 * @return
 *   The form array.
 */
function commerce_cart_add_to_cart_form($form, &$form_state, $product_ids, $show_quantity = FALSE, $default_quantity = 1) {
  global $user;

  // Store the customer uid in the form so other modules can override with a
  // selection widget if necessary.
  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $user->uid,
  );

  // Load all the products intended for sale on this form.
  $products = commerce_product_load_multiple($product_ids);

  // If no products were returned...
  if (count($products) == 0) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Product not available'),
      '#disabled' => TRUE,
    );
  }
  else {
    $form_state['products'] = $products;

    // If the form is for a single product, store the product_id in a hidden
    // form field for use by the submit handler.
    if (count($products) == 1) {
      $form['product_id'] = array(
        '#type' => 'hidden',
        '#value' => array_shift(array_keys($products)),
      );
    }
    else {
      // However, if more than one products are represented on it, attempt to
      // use smart select boxes for the product selection. If the products are
      // all of the same type and there are qualifying fields on that product
      // type, display their options for customer selection.
      $same_type = TRUE;
      $qualifying_fields = array();
      $type = '';

      // Find the default product so we know how to set default options on the
      // various Add to Cart form widgets and an array of any matching product
      // based on attribute selections so we can add a selection widget.
      $matching_products = array();
      $default_product = NULL;

      foreach ($products as $product_id => $product) {
        // Store the first product type.
        if (empty($type)) {
          $type = $product->type;
        }

        // If the current product type is different from the first, we are not
        // dealing with a set of same typed products.
        if ($product->type != $type) {
          $same_type = FALSE;
        }

        // If the form state contains a set of attribute data, use it to try
        // and determine the default product.
        if (!empty($form_state['values']['attributes'])) {
          $match = TRUE;

          foreach ((array) array_diff_key($form_state['values']['attributes'], array('product_select' => '')) as $key => $value) {
            if ($product->{$key}[LANGUAGE_NONE][0]['value'] != $value) {
              $match = FALSE;
            }
          }

          if ($match) {
            $matching_products[$product_id] = $product;
          }
        }
      }

      // Set the default product now if it isn't already set.
      if (empty($matching_products)) {
        $default_product = $products[array_shift(array_keys($products))];
      }
      else {
        // If the product selector has a value, use that.
        if (!empty($form_state['values']['attributes']['product_select']) &&
            !empty($products[$form_state['values']['attributes']['product_select']])) {
          $default_product = $products[$form_state['values']['attributes']['product_select']];
        }
        else {
          $default_product = $matching_products[array_shift(array_keys($matching_products))];
        }
      }

      // If all the products are of the same type...
      if ($same_type) {
        // Loop through all the field instances on that product type.
        foreach (field_info_instances('commerce_product', $type) as $name => $instance) {
          // A field qualifies if it is single value, required and uses a widget
          // with a definite set of options. For the sake of simplicity, this is
          // currently restricted to fields defined by the options module.
          $field = field_info_field($instance['field_name']);

          if ($field['cardinality'] == 1 && $instance['required'] && $instance['widget']['module'] == 'options') {
            // Get the options properties from the options module and store the
            // options for the instance in select list format in the array of
            // qualifying fields.
            $properties = _options_properties('select', FALSE, TRUE, TRUE);

            $qualifying_fields[$name] = array(
              'field' => $field,
              'instance' => $instance,
              'options' => _options_get_options($field, $instance, $properties),
            );
          }
        }
      }

      // Otherwise for products of varying types, display a simple select list
      // by product title.
      if (!empty($qualifying_fields)) {
        foreach ($qualifying_fields as $name => $data) {
          // Build an options array of widget options used by referenced products.
          $used_options = array();

          foreach ($products as $product_id => $product) {
            // With our hard dependency on widgets provided by the Options
            // module, we can make assumptions about where the data is stored.
            $used_options[] = $product->{$name}[LANGUAGE_NONE][0]['value'];
          }

          // If for some reason no options for this field are used, remove it
          // from the qualifying fields array.
          if (empty($used_options)) {
            unset($qualifying_fields[$name]);
          }
          else {
            $form['attributes'][$name] = array(
              '#type' => 'select',
              '#title' => check_plain($data['instance']['label']),
              '#options' => array_intersect_key($data['options'], drupal_map_assoc($used_options)),
              '#default_value' => $default_product->{$name}[LANGUAGE_NONE][0]['value'],
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
          }
        }

        if (!empty($form['attributes'])) {
          $form_id = commerce_cart_add_to_cart_form_id($product_ids, $default_quantity);

          $form['attributes'] += array(
            '#tree' => 'TRUE',
            '#prefix' => '<div class="attribute-widgets">',
            '#suffix' => '</div>',
          );

          // If there were more than one matching products for the current
          // attribute selection, add a product selection widget.
          if (count($matching_products) > 1) {
            $options = array();

            foreach ($matching_products as $product_id => $product) {
              $options[$product_id] = check_plain($product->title);
            }

            $form['attributes']['product_select'] = array(
              '#type' => 'select',
              '#title' => t('Select a product'),
              '#options' => $options,
              '#default_value' => $default_product->product_id,
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
          }

          $form['product_id'] = array(
            '#type' => 'hidden',
            '#value' => $default_product->product_id,
          );
        }
      }

      // If the products referenced were of different types or did not posess
      // any qualifying attribute fields, add a product selection widget.
      if (!$same_type || empty($qualifying_fields)) {
        $options = array();

        foreach ($products as $product_id => $product) {
          $options[$product_id] = check_plain($product->title);
        }

        $form['product_id'] = array(
          '#type' => 'select',
          '#options' => $options,
        );
      }
    }

    // Render the quantity field as either a textfield if shown or a hidden
    // field if not.
    if ($show_quantity) {
      $form['quantity'] = array(
        '#type' => 'textfield',
        '#title' => t('Quantity'),
        '#default_value' => $default_quantity,
        '#size' => 5,
      );
    }
    else {
      $form['quantity'] = array(
        '#type' => 'hidden',
        '#value' => $default_quantity,
      );
    }

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add to cart'),
    );
  }

  // Add the handlers manually since we're using hook_forms() to associate this
  // form with form IDs based on the $product_ids.
  $form['#validate'][] = 'commerce_cart_add_to_cart_form_validate';
  $form['#submit'][] = 'commerce_cart_add_to_cart_form_submit';

  return $form;
}

/**
 * Form validate handler: validate the product and quantity to add to the cart.
 */
function commerce_cart_add_to_cart_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['quantity']) || $form_state['values']['quantity'] <= 0) {
    form_set_error('quantity', t('You must specify a valid quantity to add to the cart.'));
  }

  // If the attributes matching product selector was used, set the value of the
  // product_id field to match; this will be fixed on rebuild when the actual
  // default product will be selected based on the product selector value.
  if (!empty($form_state['values']['attributes']['product_select'])) {
    form_set_value($form['product_id'], $form_state['values']['attributes']['product_select'], $form_state);
  }
}

/**
 * Ajax callback: returns AJAX commands when an attribute widget is changed.
 */
function commerce_cart_add_to_cart_form_attributes_refresh($form, $form_state) {
  $commands = array();

  // Render the form afresh to capture any changes to the available widgets
  // based on the latest selection.
  $commands[] = ajax_command_replace('#' . str_replace('_', '-', $form['#form_id']), drupal_render($form));

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Form submit handler: add the selected product to the cart.
 */
function commerce_cart_add_to_cart_form_submit($form, &$form_state) {
  $product_id = $form_state['values']['product_id'];
  $product = $form_state['products'][$product_id];

  // Add the product to the specified shopping cart.
  commerce_cart_product_add($form_state['values']['uid'], $product_id, $form_state['values']['quantity']);

  // TODO: Accommodate multiple product Add to Cart forms better; i.e. should it
  // display the product title or the product display node title?
  drupal_set_message(t('%title added to <a href="!cart-url">your cart</a>.', array('%title' => $product->title, '!cart-url' => url('cart'))));
}

/**
 * Implements hook_field_formatter_info().
 */
function commerce_cart_field_formatter_info() {
  return array(
    'commerce_cart_add_to_cart_form' => array(
      'label' => t('Add to Cart form'),
      'description' => t('Display an Add to Cart form for the referenced product.'),
      'field types' => array('commerce_product_reference'),
      'settings' => array(
        'show_quantity' => FALSE,
        'default_quantity' => 1,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function commerce_cart_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $element['show_quantity'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display a textfield quantity widget on the add to cart form.'),
      '#default_value' => $settings['show_quantity'],
    );

    $element['default_quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Default quantity'),
      '#default_value' => $settings['default_quantity'] <= 0 ? 1 : $settings['default_quantity'],
      '#element_validate' => array('commerce_cart_field_formatter_settings_form_quantity_validate'),
      '#size' => 16,
    );
  }

  return $element;
}

/**
 * Element validate callback: ensure a valid quantity is entered.
 */
function commerce_cart_field_formatter_settings_form_quantity_validate($element, &$form_state, $form) {
  if (!is_numeric($element['#value']) || $element['#value'] <= 0) {
    form_set_error(implode('][', $element['#parents']), t('You must enter a positive numeric default quantity value.'));
  }
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function commerce_cart_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $summary = array(
      t('Quantity widget: !status', array('!status' => $settings['show_quantity'] ? t('Enabled') : t('Disabled'))),
      t('Default quantity: @quantity', array('@quantity' => $settings['default_quantity'])),
    );
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function commerce_cart_field_formatter_view($entity_type, $object, $field, $instance, $langcode, $items, $display) {
  $result = array();

  // Collect the list of product IDs.
  $product_ids = array();

  foreach ($items as $delta => $item) {
    $product_ids[$item['product_id']] = $item['product_id'];
  }

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $settings = $display['settings'];

    $result[] = array(
       '#markup' => drupal_render(drupal_get_form(commerce_cart_add_to_cart_form_id($product_ids), $product_ids, $settings['show_quantity'], $settings['default_quantity'])),
     );
  }

  return $result;
}
